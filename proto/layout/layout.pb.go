// Code generated by protoc-gen-go. DO NOT EDIT.
// source: layout/layout.proto

/*
Package layout is a generated protocol buffer package.

It is generated from these files:
	layout/layout.proto

It has these top-level messages:
	Units
	Color
	Function
	Area
	Events
	Square
	Text
	TextBox
	Button
	Image
	Element
	ElementLayout
	Grid
*/
package layout

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Units_Type int32

const (
	Units_PIXEL   Units_Type = 0
	Units_PERCENT Units_Type = 1
)

var Units_Type_name = map[int32]string{
	0: "PIXEL",
	1: "PERCENT",
}
var Units_Type_value = map[string]int32{
	"PIXEL":   0,
	"PERCENT": 1,
}

func (x Units_Type) String() string {
	return proto.EnumName(Units_Type_name, int32(x))
}
func (Units_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Color_Type int32

const (
	Color_HEX  Color_Type = 0
	Color_RGBA Color_Type = 1
)

var Color_Type_name = map[int32]string{
	0: "HEX",
	1: "RGBA",
}
var Color_Type_value = map[string]int32{
	"HEX":  0,
	"RGBA": 1,
}

func (x Color_Type) String() string {
	return proto.EnumName(Color_Type_name, int32(x))
}
func (Color_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Units struct {
	Value int32      `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
	Type  Units_Type `protobuf:"varint,2,opt,name=type,enum=layout.Units_Type" json:"type,omitempty"`
}

func (m *Units) Reset()                    { *m = Units{} }
func (m *Units) String() string            { return proto.CompactTextString(m) }
func (*Units) ProtoMessage()               {}
func (*Units) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Units) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Units) GetType() Units_Type {
	if m != nil {
		return m.Type
	}
	return Units_PIXEL
}

type Color struct {
	Value string     `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	Type  Color_Type `protobuf:"varint,2,opt,name=type,enum=layout.Color_Type" json:"type,omitempty"`
}

func (m *Color) Reset()                    { *m = Color{} }
func (m *Color) String() string            { return proto.CompactTextString(m) }
func (*Color) ProtoMessage()               {}
func (*Color) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Color) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Color) GetType() Color_Type {
	if m != nil {
		return m.Type
	}
	return Color_HEX
}

// Have no idea how to make it, yet
type Function struct {
}

func (m *Function) Reset()                    { *m = Function{} }
func (m *Function) String() string            { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()               {}
func (*Function) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Area struct {
	Width         *Units `protobuf:"bytes,1,opt,name=width" json:"width,omitempty"`
	Height        *Units `protobuf:"bytes,2,opt,name=height" json:"height,omitempty"`
	MarginLeft    *Units `protobuf:"bytes,3,opt,name=marginLeft" json:"marginLeft,omitempty"`
	MarginTop     *Units `protobuf:"bytes,4,opt,name=marginTop" json:"marginTop,omitempty"`
	MarginRight   *Units `protobuf:"bytes,5,opt,name=marginRight" json:"marginRight,omitempty"`
	MarginBottom  *Units `protobuf:"bytes,6,opt,name=marginBottom" json:"marginBottom,omitempty"`
	PaddingLeft   *Units `protobuf:"bytes,7,opt,name=paddingLeft" json:"paddingLeft,omitempty"`
	PaddingTop    *Units `protobuf:"bytes,8,opt,name=paddingTop" json:"paddingTop,omitempty"`
	PaddingRight  *Units `protobuf:"bytes,9,opt,name=paddingRight" json:"paddingRight,omitempty"`
	PaddingBottom *Units `protobuf:"bytes,10,opt,name=paddingBottom" json:"paddingBottom,omitempty"`
}

func (m *Area) Reset()                    { *m = Area{} }
func (m *Area) String() string            { return proto.CompactTextString(m) }
func (*Area) ProtoMessage()               {}
func (*Area) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Area) GetWidth() *Units {
	if m != nil {
		return m.Width
	}
	return nil
}

func (m *Area) GetHeight() *Units {
	if m != nil {
		return m.Height
	}
	return nil
}

func (m *Area) GetMarginLeft() *Units {
	if m != nil {
		return m.MarginLeft
	}
	return nil
}

func (m *Area) GetMarginTop() *Units {
	if m != nil {
		return m.MarginTop
	}
	return nil
}

func (m *Area) GetMarginRight() *Units {
	if m != nil {
		return m.MarginRight
	}
	return nil
}

func (m *Area) GetMarginBottom() *Units {
	if m != nil {
		return m.MarginBottom
	}
	return nil
}

func (m *Area) GetPaddingLeft() *Units {
	if m != nil {
		return m.PaddingLeft
	}
	return nil
}

func (m *Area) GetPaddingTop() *Units {
	if m != nil {
		return m.PaddingTop
	}
	return nil
}

func (m *Area) GetPaddingRight() *Units {
	if m != nil {
		return m.PaddingRight
	}
	return nil
}

func (m *Area) GetPaddingBottom() *Units {
	if m != nil {
		return m.PaddingBottom
	}
	return nil
}

type Events struct {
	Onclick *Function `protobuf:"bytes,1,opt,name=onclick" json:"onclick,omitempty"`
	Onhover *Function `protobuf:"bytes,2,opt,name=onhover" json:"onhover,omitempty"`
}

func (m *Events) Reset()                    { *m = Events{} }
func (m *Events) String() string            { return proto.CompactTextString(m) }
func (*Events) ProtoMessage()               {}
func (*Events) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Events) GetOnclick() *Function {
	if m != nil {
		return m.Onclick
	}
	return nil
}

func (m *Events) GetOnhover() *Function {
	if m != nil {
		return m.Onhover
	}
	return nil
}

// Square area
type Square struct {
	Size       *Area   `protobuf:"bytes,1,opt,name=size" json:"size,omitempty"`
	Bgcolor    *Color  `protobuf:"bytes,2,opt,name=bgcolor" json:"bgcolor,omitempty"`
	Bindevents *Events `protobuf:"bytes,3,opt,name=bindevents" json:"bindevents,omitempty"`
}

func (m *Square) Reset()                    { *m = Square{} }
func (m *Square) String() string            { return proto.CompactTextString(m) }
func (*Square) ProtoMessage()               {}
func (*Square) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Square) GetSize() *Area {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Square) GetBgcolor() *Color {
	if m != nil {
		return m.Bgcolor
	}
	return nil
}

func (m *Square) GetBindevents() *Events {
	if m != nil {
		return m.Bindevents
	}
	return nil
}

type Text struct {
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
	Size    string `protobuf:"bytes,2,opt,name=size" json:"size,omitempty"`
	Color   *Color `protobuf:"bytes,3,opt,name=color" json:"color,omitempty"`
}

func (m *Text) Reset()                    { *m = Text{} }
func (m *Text) String() string            { return proto.CompactTextString(m) }
func (*Text) ProtoMessage()               {}
func (*Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Text) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Text) GetSize() string {
	if m != nil {
		return m.Size
	}
	return ""
}

func (m *Text) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

type TextBox struct {
	Size  *Area  `protobuf:"bytes,1,opt,name=size" json:"size,omitempty"`
	Text  *Text  `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	Color *Color `protobuf:"bytes,3,opt,name=color" json:"color,omitempty"`
}

func (m *TextBox) Reset()                    { *m = TextBox{} }
func (m *TextBox) String() string            { return proto.CompactTextString(m) }
func (*TextBox) ProtoMessage()               {}
func (*TextBox) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TextBox) GetSize() *Area {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *TextBox) GetText() *Text {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *TextBox) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

type Button struct {
}

func (m *Button) Reset()                    { *m = Button{} }
func (m *Button) String() string            { return proto.CompactTextString(m) }
func (*Button) ProtoMessage()               {}
func (*Button) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type Image struct {
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type Element struct {
	// Types that are valid to be assigned to Element:
	//	*Element_Box
	//	*Element_Textbox
	//	*Element_Button
	//	*Element_Image
	//	*Element_Grid
	Element isElement_Element `protobuf_oneof:"element"`
}

func (m *Element) Reset()                    { *m = Element{} }
func (m *Element) String() string            { return proto.CompactTextString(m) }
func (*Element) ProtoMessage()               {}
func (*Element) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isElement_Element interface {
	isElement_Element()
}

type Element_Box struct {
	Box *Square `protobuf:"bytes,1,opt,name=box,oneof"`
}
type Element_Textbox struct {
	Textbox *TextBox `protobuf:"bytes,2,opt,name=textbox,oneof"`
}
type Element_Button struct {
	Button *Button `protobuf:"bytes,3,opt,name=button,oneof"`
}
type Element_Image struct {
	Image *Image `protobuf:"bytes,4,opt,name=image,oneof"`
}
type Element_Grid struct {
	Grid *Grid `protobuf:"bytes,5,opt,name=grid,oneof"`
}

func (*Element_Box) isElement_Element()     {}
func (*Element_Textbox) isElement_Element() {}
func (*Element_Button) isElement_Element()  {}
func (*Element_Image) isElement_Element()   {}
func (*Element_Grid) isElement_Element()    {}

func (m *Element) GetElement() isElement_Element {
	if m != nil {
		return m.Element
	}
	return nil
}

func (m *Element) GetBox() *Square {
	if x, ok := m.GetElement().(*Element_Box); ok {
		return x.Box
	}
	return nil
}

func (m *Element) GetTextbox() *TextBox {
	if x, ok := m.GetElement().(*Element_Textbox); ok {
		return x.Textbox
	}
	return nil
}

func (m *Element) GetButton() *Button {
	if x, ok := m.GetElement().(*Element_Button); ok {
		return x.Button
	}
	return nil
}

func (m *Element) GetImage() *Image {
	if x, ok := m.GetElement().(*Element_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Element) GetGrid() *Grid {
	if x, ok := m.GetElement().(*Element_Grid); ok {
		return x.Grid
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Element) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Element_OneofMarshaler, _Element_OneofUnmarshaler, _Element_OneofSizer, []interface{}{
		(*Element_Box)(nil),
		(*Element_Textbox)(nil),
		(*Element_Button)(nil),
		(*Element_Image)(nil),
		(*Element_Grid)(nil),
	}
}

func _Element_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Element)
	// element
	switch x := m.Element.(type) {
	case *Element_Box:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Box); err != nil {
			return err
		}
	case *Element_Textbox:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Textbox); err != nil {
			return err
		}
	case *Element_Button:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Button); err != nil {
			return err
		}
	case *Element_Image:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Image); err != nil {
			return err
		}
	case *Element_Grid:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Grid); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Element.Element has unexpected type %T", x)
	}
	return nil
}

func _Element_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Element)
	switch tag {
	case 1: // element.box
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Square)
		err := b.DecodeMessage(msg)
		m.Element = &Element_Box{msg}
		return true, err
	case 2: // element.textbox
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextBox)
		err := b.DecodeMessage(msg)
		m.Element = &Element_Textbox{msg}
		return true, err
	case 3: // element.button
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Button)
		err := b.DecodeMessage(msg)
		m.Element = &Element_Button{msg}
		return true, err
	case 4: // element.image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Image)
		err := b.DecodeMessage(msg)
		m.Element = &Element_Image{msg}
		return true, err
	case 5: // element.grid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Grid)
		err := b.DecodeMessage(msg)
		m.Element = &Element_Grid{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Element_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Element)
	// element
	switch x := m.Element.(type) {
	case *Element_Box:
		s := proto.Size(x.Box)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Element_Textbox:
		s := proto.Size(x.Textbox)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Element_Button:
		s := proto.Size(x.Button)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Element_Image:
		s := proto.Size(x.Image)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Element_Grid:
		s := proto.Size(x.Grid)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ElementLayout struct {
	ElemPosition int32 `protobuf:"varint,1,opt,name=elemPosition" json:"elemPosition,omitempty"`
	RowStart     int32 `protobuf:"varint,2,opt,name=rowStart" json:"rowStart,omitempty"`
	RowEnd       int32 `protobuf:"varint,3,opt,name=rowEnd" json:"rowEnd,omitempty"`
	ColStart     int32 `protobuf:"varint,4,opt,name=colStart" json:"colStart,omitempty"`
	ColEnd       int32 `protobuf:"varint,5,opt,name=colEnd" json:"colEnd,omitempty"`
}

func (m *ElementLayout) Reset()                    { *m = ElementLayout{} }
func (m *ElementLayout) String() string            { return proto.CompactTextString(m) }
func (*ElementLayout) ProtoMessage()               {}
func (*ElementLayout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ElementLayout) GetElemPosition() int32 {
	if m != nil {
		return m.ElemPosition
	}
	return 0
}

func (m *ElementLayout) GetRowStart() int32 {
	if m != nil {
		return m.RowStart
	}
	return 0
}

func (m *ElementLayout) GetRowEnd() int32 {
	if m != nil {
		return m.RowEnd
	}
	return 0
}

func (m *ElementLayout) GetColStart() int32 {
	if m != nil {
		return m.ColStart
	}
	return 0
}

func (m *ElementLayout) GetColEnd() int32 {
	if m != nil {
		return m.ColEnd
	}
	return 0
}

type Grid struct {
	Size           *Area            `protobuf:"bytes,1,opt,name=size" json:"size,omitempty"`
	Color          *Color           `protobuf:"bytes,2,opt,name=color" json:"color,omitempty"`
	Rows           int32            `protobuf:"varint,3,opt,name=rows" json:"rows,omitempty"`
	Columns        int32            `protobuf:"varint,4,opt,name=columns" json:"columns,omitempty"`
	Elements       []*Element       `protobuf:"bytes,5,rep,name=elements" json:"elements,omitempty"`
	Elementslayout []*ElementLayout `protobuf:"bytes,6,rep,name=elementslayout" json:"elementslayout,omitempty"`
}

func (m *Grid) Reset()                    { *m = Grid{} }
func (m *Grid) String() string            { return proto.CompactTextString(m) }
func (*Grid) ProtoMessage()               {}
func (*Grid) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Grid) GetSize() *Area {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Grid) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *Grid) GetRows() int32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

func (m *Grid) GetColumns() int32 {
	if m != nil {
		return m.Columns
	}
	return 0
}

func (m *Grid) GetElements() []*Element {
	if m != nil {
		return m.Elements
	}
	return nil
}

func (m *Grid) GetElementslayout() []*ElementLayout {
	if m != nil {
		return m.Elementslayout
	}
	return nil
}

func init() {
	proto.RegisterType((*Units)(nil), "layout.Units")
	proto.RegisterType((*Color)(nil), "layout.Color")
	proto.RegisterType((*Function)(nil), "layout.Function")
	proto.RegisterType((*Area)(nil), "layout.Area")
	proto.RegisterType((*Events)(nil), "layout.Events")
	proto.RegisterType((*Square)(nil), "layout.Square")
	proto.RegisterType((*Text)(nil), "layout.Text")
	proto.RegisterType((*TextBox)(nil), "layout.TextBox")
	proto.RegisterType((*Button)(nil), "layout.Button")
	proto.RegisterType((*Image)(nil), "layout.Image")
	proto.RegisterType((*Element)(nil), "layout.Element")
	proto.RegisterType((*ElementLayout)(nil), "layout.ElementLayout")
	proto.RegisterType((*Grid)(nil), "layout.Grid")
	proto.RegisterEnum("layout.Units_Type", Units_Type_name, Units_Type_value)
	proto.RegisterEnum("layout.Color_Type", Color_Type_name, Color_Type_value)
}

func init() { proto.RegisterFile("layout/layout.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 747 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xcd, 0x6e, 0xda, 0x4c,
	0x14, 0xc5, 0xc1, 0x63, 0xc3, 0xcd, 0xcf, 0x87, 0xee, 0xf7, 0x23, 0x7f, 0x5d, 0x54, 0x68, 0xa2,
	0xb4, 0x51, 0xa3, 0x12, 0x35, 0x59, 0x77, 0x11, 0x47, 0x34, 0x44, 0x8a, 0x2a, 0x34, 0xa1, 0x52,
	0xba, 0x8b, 0x81, 0x29, 0x58, 0x35, 0x1e, 0x6a, 0x86, 0x40, 0xba, 0xed, 0x63, 0xf4, 0xcd, 0xf2,
	0x02, 0x7d, 0x8d, 0x6a, 0x7e, 0x4c, 0x0c, 0x75, 0xd5, 0xac, 0xec, 0xe3, 0x73, 0xce, 0xdc, 0x73,
	0x67, 0xee, 0x00, 0xfc, 0x9d, 0x44, 0xf7, 0x62, 0x2e, 0x8f, 0xcd, 0xa3, 0x35, 0xcd, 0x84, 0x14,
	0xe8, 0x19, 0x44, 0x39, 0x90, 0x0f, 0x69, 0x2c, 0x67, 0xf8, 0x0f, 0x90, 0xbb, 0x28, 0x99, 0xf3,
	0xc0, 0x69, 0x3a, 0x87, 0x84, 0x19, 0x80, 0x2f, 0xc0, 0x95, 0xf7, 0x53, 0x1e, 0x6c, 0x35, 0x9d,
	0xc3, 0xbd, 0x13, 0x6c, 0xd9, 0x35, 0xb4, 0xa5, 0xd5, 0xbb, 0x9f, 0x72, 0xa6, 0x79, 0xfa, 0x1c,
	0x5c, 0x85, 0xb0, 0x0e, 0xa4, 0x7b, 0x79, 0xd3, 0xbe, 0x6a, 0x54, 0x70, 0x1b, 0xfc, 0x6e, 0x9b,
	0x9d, 0xb7, 0xdf, 0xf7, 0x1a, 0x0e, 0xbd, 0x05, 0x72, 0x2e, 0x12, 0x91, 0xad, 0x97, 0xa9, 0xff,
	0xa1, 0x8c, 0xb6, 0x14, 0xcb, 0xfc, 0x6f, 0xcb, 0xf8, 0x50, 0xed, 0xb4, 0x6f, 0x1a, 0x15, 0xac,
	0x81, 0xcb, 0x2e, 0xc2, 0xb3, 0x86, 0x43, 0x01, 0x6a, 0xef, 0xe6, 0xe9, 0x40, 0xc6, 0x22, 0xa5,
	0x0f, 0x55, 0x70, 0xcf, 0x32, 0x1e, 0xe1, 0x3e, 0x90, 0x45, 0x3c, 0x94, 0x63, 0x5d, 0x6d, 0xfb,
	0x64, 0x77, 0x2d, 0x3f, 0x33, 0x1c, 0x1e, 0x80, 0x37, 0xe6, 0xf1, 0x68, 0x2c, 0x75, 0xf9, 0x5f,
	0x54, 0x96, 0xc4, 0xd7, 0x00, 0x93, 0x28, 0x1b, 0xc5, 0xe9, 0x15, 0xff, 0x24, 0x83, 0x6a, 0x99,
	0xb4, 0x20, 0xc0, 0x23, 0xa8, 0x1b, 0xd4, 0x13, 0xd3, 0xc0, 0x2d, 0x53, 0x3f, 0xf2, 0x78, 0x0c,
	0xdb, 0x06, 0x30, 0x9d, 0x83, 0x94, 0xc9, 0x8b, 0x0a, 0x7c, 0x03, 0x3b, 0x06, 0x86, 0x42, 0x4a,
	0x31, 0x09, 0xbc, 0x32, 0xc7, 0x9a, 0x44, 0xd5, 0x98, 0x46, 0xc3, 0x61, 0x9c, 0x8e, 0x74, 0x03,
	0x7e, 0x69, 0x8d, 0x82, 0x42, 0x35, 0x6c, 0xa1, 0x6a, 0xa1, 0x56, 0xda, 0xf0, 0xa3, 0x40, 0x45,
	0xb2, 0xc8, 0x34, 0x51, 0x2f, 0x8d, 0x54, 0x94, 0xe0, 0x29, 0xec, 0x5a, 0x6c, 0xdb, 0x80, 0x32,
	0xcf, 0xba, 0x86, 0xde, 0x82, 0xd7, 0xbe, 0xe3, 0xa9, 0x9c, 0xe1, 0x2b, 0xf0, 0x45, 0x3a, 0x48,
	0xe2, 0xc1, 0x67, 0x7b, 0xbe, 0x8d, 0xdc, 0x98, 0x4f, 0x02, 0xcb, 0x05, 0x46, 0x3b, 0x16, 0x77,
	0x3c, 0xb3, 0xa7, 0x5c, 0xaa, 0xd5, 0x02, 0xfa, 0xcd, 0x01, 0xef, 0xfa, 0xcb, 0x3c, 0xca, 0x38,
	0x36, 0xc1, 0x9d, 0xc5, 0x5f, 0xb9, 0x5d, 0x7f, 0x27, 0xf7, 0xa8, 0xe1, 0x62, 0x9a, 0xc1, 0x97,
	0xe0, 0xf7, 0x47, 0x03, 0x35, 0xa8, 0x9b, 0xe3, 0xa3, 0xa7, 0x97, 0xe5, 0x2c, 0xb6, 0x00, 0xfa,
	0x71, 0x3a, 0xe4, 0x3a, 0xbb, 0x9d, 0x9f, 0xbd, 0x5c, 0x6b, 0x3a, 0x62, 0x05, 0x05, 0xfd, 0x08,
	0x6e, 0x8f, 0x2f, 0x25, 0x06, 0xe0, 0x0f, 0x44, 0x2a, 0x79, 0x2a, 0xed, 0x9d, 0xc9, 0x21, 0xa2,
	0x0d, 0xb7, 0xa5, 0x3f, 0x9b, 0x38, 0xfb, 0x40, 0x4c, 0x98, 0x6a, 0x59, 0x18, 0xc3, 0xd1, 0x0c,
	0x7c, 0xb5, 0x74, 0x28, 0x96, 0x4f, 0x68, 0xb0, 0x09, 0xae, 0xe4, 0xcb, 0xfc, 0x72, 0xac, 0x14,
	0x6a, 0x01, 0xa6, 0x99, 0xa7, 0xd5, 0xac, 0x81, 0x17, 0xce, 0xa5, 0x14, 0x29, 0xf5, 0x81, 0x5c,
	0x4e, 0xa2, 0x11, 0xa7, 0x0f, 0x0e, 0xf8, 0xed, 0x84, 0x4f, 0x54, 0x2f, 0x14, 0xaa, 0x7d, 0xb1,
	0xb4, 0x31, 0x56, 0xdb, 0x62, 0x4e, 0xa1, 0x53, 0x61, 0x8a, 0xc4, 0x23, 0xf0, 0x55, 0x3d, 0xa5,
	0x33, 0x61, 0xfe, 0x2a, 0x86, 0x09, 0xc5, 0xb2, 0x53, 0x61, 0xb9, 0x02, 0x0f, 0xc1, 0xeb, 0xeb,
	0x7a, 0x9b, 0x5b, 0x6d, 0x52, 0x74, 0x2a, 0xcc, 0xf2, 0x78, 0x00, 0x24, 0x56, 0x79, 0x36, 0x6f,
	0xa9, 0x0e, 0xd9, 0xa9, 0x30, 0xc3, 0x22, 0x05, 0x77, 0x94, 0xc5, 0x43, 0x7b, 0x39, 0x57, 0xfb,
	0x70, 0x91, 0xc5, 0xc3, 0x4e, 0x85, 0x69, 0x2e, 0xac, 0x83, 0xcf, 0x4d, 0x43, 0xf4, 0xbb, 0x03,
	0xbb, 0xb6, 0xb9, 0x2b, 0xad, 0x44, 0x0a, 0x3b, 0x8a, 0xec, 0x8a, 0x59, 0xac, 0xe6, 0xcd, 0xfe,
	0xd0, 0xae, 0x7d, 0xc3, 0x67, 0x50, 0xcb, 0xc4, 0xe2, 0x5a, 0x46, 0x99, 0xd9, 0x70, 0xc2, 0x56,
	0x18, 0xff, 0x03, 0x2f, 0x13, 0x8b, 0x76, 0x3a, 0xd4, 0x1d, 0x11, 0x66, 0x91, 0xf2, 0x0c, 0x44,
	0x62, 0x3c, 0xae, 0xf1, 0xe4, 0x58, 0x79, 0x06, 0x22, 0x51, 0x1e, 0x62, 0x3c, 0x06, 0xd1, 0x1f,
	0x0e, 0xb8, 0x2a, 0xf9, 0x13, 0xce, 0x7f, 0x75, 0xba, 0x5b, 0xbf, 0x3f, 0x5d, 0x35, 0x8a, 0x99,
	0x58, 0xcc, 0x6c, 0x32, 0xfd, 0x6e, 0x06, 0x37, 0x99, 0x4f, 0xd2, 0x99, 0x8d, 0x95, 0x43, 0x3c,
	0x82, 0x9a, 0xdd, 0xa6, 0x59, 0x40, 0x9a, 0xd5, 0xe2, 0x49, 0xda, 0x2d, 0x63, 0x2b, 0x01, 0xbe,
	0x85, 0xbd, 0xfc, 0xdd, 0x68, 0x02, 0x4f, 0x5b, 0xfe, 0xdd, 0xb0, 0x98, 0x5d, 0x66, 0x1b, 0xe2,
	0x10, 0xc1, 0x33, 0x4c, 0x68, 0x9f, 0x5d, 0xa7, 0xef, 0xe9, 0xff, 0xc0, 0xd3, 0x9f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xdd, 0x4a, 0xb3, 0xd0, 0x1a, 0x07, 0x00, 0x00,
}
